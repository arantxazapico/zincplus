\documentclass[11pt,letterpaper,usenames,dvipsnames]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PACKAGES
\usepackage{amsmath,amssymb,amsthm}
\usepackage{fullpage}
\usepackage{multirow}
\usepackage{bbm,soul}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{lipsum}
\usepackage{makecell}
\usepackage{bm}
\usepackage{braket}
\usepackage{adjustbox,mdframed}
\usepackage[operators,sets,primitives,asymptotics,lambda,keys,ff]{cryptocode}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage[font=footnotesize,labelfont=bf]{caption}
\usepackage{mleftright}
\usepackage{wrapfig}
\usepackage{setspace}
\usepackage{xspace}
\usepackage{algorithm,algorithmic}
\floatname{algorithm}{Protocol}
%\crefname{algorithm}{Protocol}{Protocols}
%\Crefname{algorithm}{Protocol}{Protocols}
\renewcommand{\algorithmiccomment}[1]{// #1}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{authblk}

\usepackage{framed}
\usepackage{comment}
\usepackage{placeins} % in the preamble

\usepackage{float}
\usepackage{graphicx}
\graphicspath{ {./figures/} }
\usepackage[T1]{fontenc}
\usepackage{titlesec}
\usepackage{stmaryrd}

\usepackage[backend=biber,giveninits,style=alphabetic,maxalphanames=6,maxnames=6,backref]{biblatex}
\addbibresource{references.bib} 
%\addbibresource{cryptobib/abbrev3.bib} 
%\addbibresource{cryptobib/crypto_crossref.bib}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\plaintitle}{Zinc{+}}
\newcommand{\stylizedtitle}{\textsf{Zinc{+}}}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=CadetBlue,
    breaklinks=true,
    citecolor=Periwinkle,      
    urlcolor=Emerald,
    pdftitle={\plaintitle},
    pdfpagemode=FullScreen,
}
\DefineBibliographyStrings{english}{%
  backrefpage = {cited on p.},% originally "cited on page"
  backrefpages = {cited on pp.},% originally "cited on pages"
}
% Remove starred sections from toc
\DeclareRobustCommand{\SkipTocEntry}[5]{} 
\usepackage[capitalize, nameinlink]{cleveref}
\usepackage{tikz}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{macros}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\stylizedtitle}

\newcommand{\FormatAuthor}[3]{%
\begin{tabular}{c}
#1 \\ {\small\texttt{#2}} \\ {\small #3}
\end{tabular}
}

\author{
	Albert Garreta, Psi Vesely, Arantxa Zapico
}
\date{\today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\setcounter{tocdepth}{2}
\begin{spacing}{0.8}
{\footnotesize \tableofcontents}
\end{spacing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}


\subsection{Rings and rings of polynomials} Throughout the paper we extensively work with multivariate polynomials whose coefficients are polynomials themselves. Formally, given a ring $\cR$ and variables $\YY=(Y_1,\ldots, Y_\mu)$, we let $\cR[\YY]$ denote the ring of multivariate polynomials on variables $\YY$, with coefficients inn $\cR$. For us, typically $\cR$ will be of the form $\ZZ[X]$ or $\QQ[X]$ (or even $\local{q}[X]$ for some prime $q$). In that case, $\cR[\YY]$ contains all polynomials on variables $\YY$ whose coefficients are polynomials from $\ZZ[X]$ (or $\QQ[X]$, or $\local{q}[X]$). 

The ring $(\ZZ[X])[\YY]$ is isomorphic to the ring $\ZZ[X, \YY]$ of all polynomials with integer coefficients on variables $(X,\YY)$  (and similarly for $(\QQ[X])[\YY]$ and $(\local{q}[X])[\YY]$). However, in this work we do not use this isomorphic representation of our polynomials, and insist on viewing elements from $(\ZZ[X])[\YY]$ as polynomials on the variables $\YY$ with coefficients in $\ZZ[X]$. We denote such a polynomial by $$f(X;\YY),$$
highlighting the presence of the variable $X$. The reason for doing so is that sometimes we will want to evaluate $X$ at a specific value $x$, obtaining a polynomial $f(x;\YY)$ in $\ZZ[\YY]$, and sometimes we will need to evaluate the variables $\YY$ at a specific values $\yy$, and we will look at the result as  a polynomial $f(X,\yy)$ in $\ZZ[X]$. 

In general, we denote vectors of elements with lowercase boldface letters, e.g.\ $\vv,\uu,$ etc. Given a ring $\cD$ (typically $\ZZ, \QQ$, or $\local{q}$), we denote vectors of elements from $(\cD[X])[\YY]$ as $\vv(X;\YY), \uu(X;\YY)$, etc.


For every ring $\cR$ we work with we fix a publicly known representation of its elements as strings of bits. By $\cR_{\leq B}$ we denote the subset of $\cR$ formed by all elements whose bitstring representation contains at most $B$ bits. In \cref{s: bistring_reps} we describe the representation we use for the rings $\ZZ,\QQ, \ZZ[X],$ and $\QQ[X]$ \albert{And $\local{q},\local{q}[X]$?}.

\subsection{Bitstring representation of ring elements}\label{s: bistring_reps}
\albert{To do.}

\section{Algebraic constraints over $\QQ[X]$ with evaluation predicates}

In this section we define the type of constraints we are interested in working on. As we argued in \cref{?}, and as we see later in \cref{?}, these constraints are highly expressive, and can  express essentially all computations of interest with almost no arithmetization overhead.


Let $\cQ$ be a set of polynomials with coefficients in $\QQ[X]$ (possibly multivariate and of arbitrary degree). Let $\gp = (k, m, n, \mu, B)$ be global parameters, where $k,m,n,B$ are size parameters. An algebraic relation for $(\gp,\cQ)$ is a set $\REL_{\gp, \cQ}$ of triples $(\idx, \inp;\wit)$ with the following properties:
\begin{itemize}
	\item The \emph{index} $\idx$ contains $n$ oracles $\oracle{g_1(X;\YY)}, \ldots, \oracle{g_n(X;\YY)}$ to multilinear polynomials $(\QQ[X])_{\leq B}^\multilin[\YY]$, where $\YY=(Y_1,\ldots, Y_\mu) $ is a tuple of variables.
	 \item $\cQ$ is a set of polynomials with coefficients in $\QQ[X]$, each on $(n+ k)\cdot 2^\mu + m$ variables.
	\item $\wit$ is a vector consisting of $k$ multilinear polynomials $f_1(X;\YY),\ldots, f_k(X;\YY)$ from $(\QQ[X])_{\leq B}^{\multilin}[\YY]$. %and the multilinear polynomials $g_1,\ldots, g_n\in \R_B^\multilin[\XX]$.
	\item $\inp=(\zz(X), \oracle{f_1(X;\YY)}, \ldots, \oracle{f_k(X;\YY))}$, where $\zz\in (\QQ[X])_{\leq B}^m$.
	\item Each of the polynomials in $\cQ$ vanishes (as a polynomial in $\QQ[X]$) when evaluated on the values $$((g_1(X;\yy),\ldots, g_n(X;\yy), f_1(\yy),\ldots, f_k(X;\yy))_{\yy\in \BB^\mu}, \yy(X)).$$ 
	\end{itemize}

\begin{equation*}
\begin{aligned}
	
\end{aligned}	
\end{equation*}

    \subsection{PIOP over a ring, projections, and lifts}

    We start by outlining our setting and presenting some tools we will work with. Mainly, we define what we mean by a relation to be algebraic over a ring $\R$, and we establish correspondences between PIOPs for a relation over a ring $\R$, and a PIOP for an homomorphic image $\R'$ of $\R$. A reader wishing to tone down the abstractness of the presentation can replace $\R$ by the local ring $\local{q}$ (or even $\ZZ$, even though we will never instantiate the schemes in this section on $\ZZ$), and $\R'$ by $\FF_q$, for $q$ a prime.

    
    Recall that, given a ring $\R$, we implicitly fix an encoding of its elements as strings of bits. Given $B\geq 1$, by $\R_B$ we denote the subset of $\R$ consisting of ring elements whose encoding has at most $B$ bits.

    \begin{definition}[Algebraic  indexed relation over a ring $\R$]
    \label{d: Algebraic  Indexed Relation over a ring}
    Let $\R$ be a ring, and let $\cQ$ be a set of polynomials with coefficients in $\R$ (possibly multivariate and of arbitraty degree). Let $\gparams=(k,m,n,\mu, B)$ be  global parameters where $k,m,n,\mu,B$ are size parameters.  Abusing the language, we set $\gparams$ to also include the security parameter $\lambda$, the ring $\R$, and the polynomials $\cQ$, but we do not explicitly display them inside $\gparams$. Instead, we refer to $\R, \cQ$ in more explicit ways. We do so because in our constructions, $\gparams$ stays fixed, while $\R$ and $\cQ$ often vary.
    
    An \emph{algebraic indexed relation for the parameters $(\gparams, \R, \cQ)$}  is a set $\REL_{\gparams,\R,\cQ}$ of triples $(\idx, \inp; \wit)$ with the following properties:
    
        \begin{itemize}
            \item The \emph{index} $\idx$ contains  $n$ oracles $\oracle{g_1},\ldots, \oracle{g_n}$ to multilinear polynomials $g_1,\ldots, g_n\in \R_B^\multilin[\XX]$, where $\XX=(X_1,\ldots, X_\mu)$.
            \item $\cQ$ is a set of polynomials with coefficients in $\R$, each on $(n+ k)\cdot 2^\mu + m$ variables.
            \item $\wit$ is a vector consisting of $k$ multilinear polynomials $f_1(\XX),\ldots, f_k(\XX)$ from $\R_B^{\multilin}[\XX]$. %and the multilinear polynomials $g_1,\ldots, g_n\in \R_B^\multilin[\XX]$.
            \item $\inp=(\yy, \oracle{f_1}, \ldots, \oracle{f_k})$, where $\yy\in \R_B^m$.
            \item Each of the polynomials in $\cQ$ vanishes when evaluated on the values $$((g_1(\xx),\ldots, g_n(\xx), f_1(\xx),\ldots, f_k(\xx))_{\xx\in \BB^\mu}, \yy).$$ 
        \end{itemize}
    
    Formally, $\REL_{\gparams,\R,\cQ}$ has the following form:
    %
    \begin{equation*}
    \begin{aligned}
    \REL_{\gparams,\R,\cQ} = \left\{ (\idx, \inp ; \wit) \left| \ \begin{aligned}
    & \gparams=(k,m,n,\mu, B),  \\
    & \idx = ( \oracle{g_1},\ldots, \oracle{g_n}), \\
    & \inp =(\yy, \oracle{f_1}, \ldots, \oracle{f_k}) \text{ for some } \yy\in \R_B^{m},\\    
        &\wit = (f_1(\XX), \ldots, f_k(\XX)) \in \left(\R_B^{^{\multilin}}[\XX]\right)^{n},    \ \XX=(X_1,\ldots, X_\mu),\\
        &(g_1(\XX),\dots,g_n(\XX))\in \left(\R_B^{^{\multilin}}[\XX]\right)^{n},\\
        &Q((g_1(\xx),\ldots, g_n(\xx), f_1(\xx),\ldots, f_k(\xx))_{\xx\in \BB^\mu}, \yy) =0  \text{ for all } Q\in \cQ
    \end{aligned} \right.\right\}
    \end{aligned}
    \end{equation*}
    \end{definition}
  %
    In \cref{ex: The CCS relation as an algebraic indexed relation} we show that both the CCS relation and the lookup relation (\cref{s: CCS}) can be rewritten as algebraic indexed relations.  In the next definition we generalize the notion of algebraic indexed relation.
%
      \begin{definition} [Projected algebraic indexed relation]\label{d: Projected Algebraic  Indexed Relation over a ring}
    Let $\REL_{\gparams,\R,\cQ}$ be an algebraic indexed relation with parameters $(\gparams, \R, \cQ)$, and let $\phi:\R \to \R'$ be a ring homomorphism. We define an associated relation, which we call \emph{$\phi$-projected algebraic indexed relation}, denoted by $\phi(\REL_{\gparams,\R, \cQ})$, as the relation $\REL_{\gparams,\R, \cQ}$, with the only difference that in $\phi(\REL_{\gparams,\R, \cQ})$ we require that the image by $\phi$ of the polynomials in $\cQ$ vanishes. Formally (we highlight the difference between $\REL_{\gparams,\R, \cQ}$ and $\phi(\REL_{\gparams,\R, \cQ})$ in blue):
    %
    \begin{equation*}
    \begin{aligned}
    \phi(\REL_{\gparams,\R,\cQ}) = \left\{ (\idx, \inp ; \wit)\left| \ \begin{aligned}
    &\gparams \coloneqq(k,m,n,\mu, B),\  \\
    &\idx \coloneqq(\oracle{g_1},\ldots, \oracle{g_n}), \\
    &\inp =(\yy, \oracle{f_1}, \ldots, \oracle{f_k}) \text{ for some } \yy\in \R_B^{m},\\
        &\wit = (f_1(\XX), \ldots, f_k(\XX)) \in \left(\R_B^{^{\multilin}}[\XX]\right)^{k},    \ \XX=(X_1,\ldots, X_\mu),\\
        &(g_1(\XX),\dots,g_n(\XX))\in \left(\R_B^{^{\multilin}}[\XX]\right)^{n},\\
        &\textcolor{blue}{\phi(Q((g_1(\xx),\ldots, g_n(\xx), f_1(\xx),\ldots, f_k(\xx))_{\xx\in \BB^\mu}, \yy)) =0} \\ &\quad\quad\quad\quad\quad\quad\quad \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\text{ for all } Q\in \cQ 
    \end{aligned} \right.\right\}
    \end{aligned}
    \end{equation*}
    \end{definition}
    Importantly, in a projected algebraic indexed relation, the oracles and polynomials in $(\idx,\inp;\wit)$ are over the ring $\R$, even though the constraints posed by the polynomials $\cQ$ are enforced only under the image of $\phi$. 

    Notice that, by taking $\R'=\R$ and $\phi$ the identity homomorphism (i.e.\ $\phi(a)=a$ for all $a\in \R$) we have that $\phi(\REL_{\gparams,\R, \cQ}) = \REL_{\gparams,\R, \cQ}$. Hence, projected algebraic indexed relations are a generalization of algebraic indexed relations. 

    \begin{definition}[Well-formed index-instance pairs]\label{d: valid_index_instance_pair}
        Let $\phi(\REL_{\gparams,\R, \cQ})$ be a projected algebraic indexed relation. Following \cref{r: well_formed_convention}, we say that $(\idx,\inp)$ is a \emph{well-formed index-instance pair for the relation $\phi(\REL_{\gparams,\R, \cQ})$} if $\idx$ and $\inp$ have the form specified in the definition of $\phi(\REL_{\gparams,\R, \cQ})$. Namely, if $\idx=(\gparams,\oracle{g_1},\ldots, \oracle{g_n})$ and $\inp= (\yy, \oracle{f_1},\ldots, \oracle{f_k})$  where $g_1, \ldots, g_n, f_1,\ldots, f_k$ are all $\mu$-variate multilinear polynomials from $\R_B[\XX]$, and $\yy$ is a tuple of $m$ elements from $\R_B$.
        %\hendrik{Now that we have that here, do we still want to keep it in the preliminaries?}
    \end{definition}

\begin{comment}
   \begin{definition}[{Algebraic PIOP for a  (projected) algebraic indexed relation over $(\R,\cQ)$}]
   
   Let $\REL_{\R,\cQ}$ be an algebraic indexed relation over $(\R,\cQ)$, and let $\phi : \R \to \R'$ be a ring homomorphism (possibly the identity homomorphism). %Let $\cF$ be a map assigning tuples of natural numbers to tuples of polynomials over $\R'$.  \albert{We are not really using the $\cF$ polynomials.}
   
   An \emph{Algebraic PIOP} $\prot$ for $\phi(\REL_{\R,\cQ})$ and $\cF$ is a PIOP for $\phi(\REL_{\R,\cQ})$ in which $\verifier$ is given as input a well-formed  index-instance pair $(\idx, \inp)$ for the relation  $\phi(\REL_{\R,\cQ})$, and $\prover$ is given additionally a witness $\wit$ such that $(\idx, \inp;\wit) \in \phi(\REL_{\R,\cQ})$. In this PIOP, all oracles sent by the prover are oracles to multilinear %\albert{ok or too restrictive?} \hendrik{Should be fine given the MLE, no?}  \albert{I mean that we could allow prover to send polynomials of arbitrary degrees} 
   polynomials with coefficients in $\R'$, and all messages from $\verifier$  are uniformly sampled in finite subsets of $\R'$. %Further, at the end of the interaction with the prover,  after having queried the received oracles, $\verifier$ accepts or rejects based on whether the polynomials in $\cF(\gparams)$ are zero when evaluated on the verifier's queried values and ring elements in $\inp$ (after applying $\phi$ to them if they belong to $\R$), and the messages sent by $\verifier$.   
   \albert{Is this formal enough?}\hendrik{I think it is fine, I think we should have to the same degree of formality as the initial PIOP definition.}

   \end{definition}
\end{comment}
     %
     %Formally, $\prot=(\prover, \verifier)$ is a PIOP for $\REL_{\R, S, \cQ}$.  At round $i\in[k-1]$, $\prover$ sends an oracle $\oracle{h_i}$ to $\verifier$, where $h_i\in \R^{\leq d_i}[X_1,\ldots, X_{n_i}]$ and $d_i, n_i\geq 1$ are parameters specified in $\gp \gets \setup(1^\lambda)$. $\verifier$ replies with a vector of ring elements uniformly sampled over a finite prescribed subset $\codelin_i$ of $\R^{t_i}$, where $\codelin_i$ and $t_i$ are again specified in $\gp$. At the last round, $\prover$ sends one last oracle $\oracle{f_k}$, with $h_k\in \RR^{\leq d_k}[X_1,\ldots, X_{n_k}]$. $\verifier$ then makes  queries to the oracles $\oracle{h_1},\ldots, \oracle{h_k}$ at  random points, say it queries $\oracle{h_i}$ at points $\xx_{i1},\ldots, \xx_{im_i}\in \RR^{n_i}$, for each $i\in [k]$, where the $m_i$ are parameters specified in $\gp$ \albert{It can also query the oracles in the index and in the instance}.  Let $\yy = (y_{ij})_{i\in [k],\ j\in [m_i]}$ be the values received from querying the oracles. Then  $\verifier$ checks whether \albert{we should also allow $\verifier$ to use the ring elements in $\inp'$}
     %
     %$$
    %F(\yy) = 0,
     %$$
     %where $F$ is a polynomial from $\R[Y_1,\ldots, Y_{\sum_{i\in [k]} m_i}]$ which is specified in $\gp$. Then $\verifier$ accepts (returns $1$) or rejects (returns $0$) depending on whether $F(\yy) = 0$ or not.
    

    
    % \begin{definition} [Fully projected algebraic indexed relation]
    % Let $\REL_\R$ be an algebraic indexed relation over $(\R,S)$, and let $\phi:\R \to \R'$ be a ring homomorphism.
    % We define an associated relation called \emph{$\phi$-fully projected algebraic indexed relation} as the relation $\REL_{\phi(\R), \phi(S)}$. Formally:
    % %
    %     \begin{equation*}
    % \REL_{\phi(\R), \phi(S)}) = \left\{ (\idx, \inp;\wit) \left| \ \begin{aligned}&\text{There exists } (\idx_\R, \inp_\R;\wit_\R)\in \REL_{\R,\cQ} \text{ such that: } \\ &\inp=\phi(\inp_\R),\ \wit = \phi(\wit_\R),\\
    % & \idx_\R = (k,m,n,\mu, \oracle{g_1},\ldots, \oracle{g_n}, Q),\\
    % &\idx = (k,m,n,\mu, \oracle{\phi(g_1)}, \ldots, \oracle{\phi(g_n)}, \phi(Q))\end{aligned} \right.\right\}
    % \end{equation*}
    % \end{definition}

    Let $\phi:\R\to \R'$ be a ring homomorphism and let $\REL_{\gparams,\R, \cQ}$ be an algebraic indexed relation. By $\phi(\cQ)$ we define the set containing the image under $\phi$ of the polynomials in $\cQ$. One can then consider the relation $\REL_{\gparams,\R', \phi(\cQ)}$. By definition, this is precisely, 
    %
    \begin{equation*}
    \begin{aligned}
    \REL_{\gparams,\R',\phi(\cQ)} = \left\{ (\idx, \inp ; \wit)\left| \ \begin{aligned}
    &\gparams = (k,m,n,\mu, B),\ n,m,k,B\geq 1, \\
    &\idx = (\oracle{g_1},\ldots, \oracle{g_n}), \\
    &\inp =(\yy, \oracle{f_1}, \ldots, \oracle{f_k}) \text{ for some } \yy\in \left(\R_B'\right)^{m},\\
        &\wit = (f_1(\XX), \ldots, f_k(\XX)) \in \left(\R_B'{}^{^{\multilin}}[\XX]\right)^{k}, \  \XX=(X_1,\ldots, X_\mu),\\
        &(g_1(\XX),\dots,g_n(\XX)\in \left(\R_B'{}^{^{\multilin}}[\XX]\right)^{n},\\
        &\phi(Q)((g_1(\xx),\ldots, g_n(\xx), f_1(\xx),\ldots, f_k(\xx))_{\xx\in \BB^\mu}, \yy) =0 \\ &\quad\quad\quad\quad\quad\quad\quad \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\text{ for all } Q\in \phi(\cQ)
    \end{aligned} \right.\right\}
    \end{aligned}
    \end{equation*}

    The following definition is necessary to make sure many of the constructions in this section are well defined and result in efficient algorithms. 

    \begin{definition}[Efficient homomorphism $\phi$]\label{d: efficient_homomorphism}
        We say that a ring homomorphism $\phi:\R \to \R'$ is \emph{efficient} if 1) $\phi(\R_B)= \R_B'$\footnote{We ask that  bit-size bound in $\R$ and in $\R'$ is the same simply due to ease of presentation. The  condition could be relaxed to asking that $\phi(\R_B)= \R_{B'}'$ for a new parameter $B'$. In that case, our results still hold after making straightforward changes to their statements and corresponding proofs.} for all $B\geq 1$ (in words, the image by $\phi$ of the elements from $\R$ of bit-size less than $B$ can be written with less than $B$ bits); 2) $\phi(a)$ can be computed in polynomial time on the bit-size of $a$, for all $a\in \R$; and 3) given $a'\in \R_B'$, it is possible to find $a\in \R_B$ such that $\phi(a)=a'$ in polynomial time on the bit-size of $a'$.
    \end{definition}

    Given an index $\idx=(\oracle{g_1},\ldots, \oracle{g_n})$ for $\REL_{\gparams, \R, \cQ}$ and a homomorphism $\phi:\R \to \R'$, we define $\phi(\idx)=( \phi(\oracle{g_1}),\ldots, \phi(\oracle{g_n}))$.

The next observation follows immediately from \cref{d: efficient_homomorphism}.
\begin{remark}\label{r: well_formedness_preservation}
Suppose $\phi:\R \to \R'$  is an efficient ring homomorphism. Then, given any well-formed index-instance pair $(\idx,\inp)$ for $\phi(\REL_{\gparams,\R,\cQ})$, we have that $(\phi(\idx), \phi(\inp))$ is a well-formed index-instance pair for $\REL_{\gparams,\R', \phi(\cQ)}$ which can be computed efficiently. 

Conversely, given a well-formed index-instance pair $(\idx',\inp')$ for $\REL_{\gparams,\R',\cQ'}$, there exists a well-formed index-instance pair $(\idx,\inp)$ for $\phi(\REL_{\gparams,\R,\cQ})$ that can be computed efficiently.
\end{remark}

    
    Given an oracle $\oracle{f}$ to a polynomial $f\in \R[\XX]$, we let $\phi(\oracle{f})= \oracle{\phi(f)}$. In the scenario where $\verifier$ has received an oracle $\oracle{f}$, $\verifier$ can query the oracle $\phi(\oracle{f})$ as follows: first, it queries $\oracle{f}$ at the desired position, and then $\verifier$ applies the homomorphism $\phi$ to the received value. %\albert{I guess we have to say somewhere that $\phi$ is known to everyone and efficiently computable}\hendrik{For the former, can we just make it part of the statement?}.

   \begin{lemma}\label{l: valid_instance_preserved_by_phi}
        Let $\phi:\R\to \R'$ be an efficient ring homomorphism, and    let  $(\idx,\inp)$ be a well-formed index-instance pair for  $\phi(\REL_{\gparams,\R, \cQ})$. Then   $(\idx,\inp)\in \LANG(\phi(\REL_{\gparams,\R, \cQ}))$ if and only if $(\phi(\idx),\phi(\inp))\in \LANG(\REL_{\gparams,\R', \phi(\cQ)})$. 
   \end{lemma}

  
     Now, let $\prot_\R'$ be a PIOP over $\R'$ for $\REL_{\gparams,\R', \phi(\cQ)}$. We introduce the notion of the lift of $\prot_\R'$. Informally, this is a PIOP over $\R$ for $\phi(\REL_{\gparams,\R, \cQ})$ where $\prover$ and $\verifier$ simply apply the map $\phi$ to all  elements from $\R$ and polynomials with coefficients in $\R$, and then execute $\prot_\R'$.

        \begin{definition}[Lift of a PIOP] \label{d: Lift of an Algebraic PIOP}
     Let $\REL_{\gparams,\R,\cQ}$ be an algebraic indexed relation with parameters $(\gparams, \R,\cQ)$. Let $\phi:\R \to \R'$ be an efficient (cf.\ \cref{d: efficient_homomorphism}) ring homomorphism.  Let $\prot_{\R'}=( \indexer_{\R'}, \prover_{\R'},\verifier_{\R'})$ be a PIOP over $\R'$ for $\REL_{\gparams,\R',\phi(\cQ)}$. In \cref{a: lift} we describe a PIOP over $\R$ for $\phi(\REL_{\gparams,\R, \cQ})$, denoted $\prot_{\R'}^{\lift}= (\indexer_{\R'}^\lift, \prover_{\R'}^\lift,\verifier_{\R'}^\lift)$, and called the \emph{lift of $\prot_\R'$ onto $\R$}. 

        	\begin{algorithm}[H]
		\caption{A PIOP $\prot_{\R'}^{\lift}=(\indexer_{\R'}^\lift,\prover_{\R'}^\lift, \verifier_{\R'}^\lift)$ over $\R$ for the relation $ \phi(\REL_{\gparams, \R,\cQ})$, called the \emph{lift} of $\prot_\R'=(\indexer_{\R'},\prover_{\R'}, \verifier_{\R'})$. \label{a: lift}}%\begin{algorithmic}[H]
		%{}
		            
        \textbf{Indexer:}      Given $\gparams$ and $\idx=(\oracle{g_1},\ldots, \oracle{g_n})$ for $\phi(\REL_{\gparams,\R, \cQ})$, the indexer $\indexer_{\R'}^\lift$ runs $\indexer_{\R'}$ on input $\gparams$ and $\phi(\idx)$, and obtains verifier and prover parameters $\vp, \pp$ as output. By definition (cf.\ \cref{s: iop}), $\vp=(\vp', (\oracle{\phi(g_i)})_{i\in [n]})$ and $\pp=(\pp', (\phi(g_i))_{i\in [n]})$ for some $\vp', \pp'$. Then  $\indexer_{\R'}^\lift$ outputs $\vp^\lift = (\vp', (\oracle{g_i})_{i\in [n]})$ and $\pp^\lift = (\pp', (g_i)_{i\in [n]})$.
        \vspace{0.3cm}
        
        %\end{algorithmic}%\newline
        	\textbf{Input:} Let $(\idx,\inp)$ be a well-formed index-instance pair for $\phi(\REL_{\gparams,\R, \cQ})$. $\prover_{\R'}^\lift$ and $\verifier_{\R'}^\lift$ receive $(\pp^\lift, \inp,\wit)$   and $(\vp^\lift, \inp)$ as input, respectively, where $(\vp^\lift, \pp^\lift) \gets \indexer_{\R'}^\lift(\gparams,\idx)$. Let  $(\vp, \pp) \gets \indexer_{\R'}(\gparams,\phi(\idx))$.\vspace{0.3cm}%\begin{algorithmic}[H]
        %{}
        	%\end{algorithmic} %\newline

        
        %\newline
	 %Additionally, $\prover_{\R'}^\lift$ receives $\wit$ such that
          %$(\idx, \inp; \wit)\in \phi(\REL_{\gparams,\R,  \cQ})$. 
          \textbf{Interactive phase:}   Let $k$ be the number of communication rounds  in $\prot_{\R'}$, and let $\cM_1, \ldots, \cM_{k+1}, \cC_1,\ldots, \cC_k$ be the message and challenge spaces of $\prot_{\R'}$.
        %\newline
        %
		\begin{algorithmic}[1]
			%\small
			\STATE Let $m_1$ be a first message output by $\prover_{\R'}(\pp, \phi(\inp);\phi(\wit))$. Then $\prover_{\R'}^{\lift}$ sends $m_1$ to $\verifier_{\R'}^{\lift}$.
            \STATE For $i=1,\ldots, k$,
            \begin{itemize}
                \item $\verifier_{\R'}^{\lift}$ uniformly samples a challenge $\rho_i$ in the challenge space $\cC_i$, and sends $\rho_i$ to $\prover_{\R'}^{\lift}$. 
                \item Let $m_{i+1}$ be output by $\prover_{\R'}(\pp,\phi(\inp);\phi(\wit))$ after having output messages $m_1, \ldots, m_{i}$ and received challenges $\rho_{1},\ldots, \rho_{i}$.  Then $\prover_{\R'}^{\lift}$ sends $m_{i+1}$ to $\verifier_{\R'}^{\lift}$. 
            \end{itemize}
            \STATE $\verifier_{\R'}^\lift$ outputs $\verifier_{\R'}(\vp, \phi(\inp), m_1, \rho_1,\ldots, m_k, \rho_{k}, m_{k+1})$. %: whenever $\verifier_{\R'}$ would query an oracle sent by $\prover_\R'$ during the interactive phase, $\verifier_{\R'}^\lift$ queries the same oracle at the same position. Whenever $\verifier_{\R'}$ would query an oracle $\phi(\oracle{h})$ in $\phi(\idx)$ or in $ \phi(\inp)$, $\verifier_{\R'}^\lift$ queries $\oracle{h}$ at the same position, and applies $\phi$ to the received value. Finally, $\verifier_{\R'}^\lift$ accepts if and only if $\verifier_{\R'}$ would accept when given the input $(\phi(\idx), \phi(\inp))$  the challenges sent by $\verifier_{\R'}^\lift$, and the values queried by $\verifier_{\R'}^\lift$.
            %For $i=1,\ldots, k$, let $\rho_i$ be the last challenge sent by $\verifier_{\R'}$
		\end{algorithmic}
	\end{algorithm}
          \end{definition}
    

        
        


        %begin{lemma}
        %     \albert{Is this needed? } Let $(\idx,\inp)$ be a well-formed index-instance pair for $\phi(\REL_{\R, \cQ})$. Let $\tr=(\rho_1, m_1,\ldots, \rho_k, m_{k})$ be a transcript of an execution of $\langle \prover_{\R'}^{\lift}(\idx, \inp), \verifier_{\R'}^{\lift}(\idx, \inp) \rangle$. Then $\tr=(\rho_1, m_1,\ldots, \rho_k, m_{k})$ is also a transcript of an execution of $\langle \prover_{\R'}(\phi(\idx), \phi(\inp)), \verifier_{\R'}^{\lift}(\phi(\idx), \phi(\inp)) \rangle$, and    
       % $\verifier_{\R'}^{\lift}(\idx, \inp, \tr)=1$ if and only if $\verifier_{\R'}(\phi(\idx), \phi(\inp), \tr)=1$.
       % \end{lemma}
       % \begin{proof}
  
       % \end{proof}

        %\albert{remove} Under the same setting as in the above \cref{d: Lift of an Algebraic PIOP}, given a malicious prover $\prover_{\R'}^{\lift,*}$ for $\prot_{\R'}^\lift$, we define a malicious prover $\prover_{\R'}^{*}$ for $\prot_{\R'}$. %similarly as we defined $\prover_{\R'}^{\lift}$. 
        %Namely, given $(\idx,\inp)$  as input, $\prover_{\R'}^{*}$  executes $\prover_{\R'}^{*}$ with input $(\phi(\idx),\phi(\inp))$ and sends to $\verifier_{\R'}^{\lift}$ the same oracles that  $\prover_{\R'}^{*}$ would send to  $\verifier_{\R'}$
    
        \begin{lemma}\label{l: lift_preserves_soundness}
        Let $\REL_{\gparams,\R,\cQ}$ be an algebraic indexed relation with parameters $(\gparams,\R,\cQ)$. Let $\phi:\R \to \R'$ be an efficient ring homomorphism. Let $\prot_{\R'}=(\indexer_{\R'}, \prover_{\R'}, \verifier_{\R'})$ be a  PIOP over $\R'$ for an algebraic indexed relation $\REL_{\gparams,\R',\phi(\cQ)}$. Suppose $\prot_{\R'}$ has soundness error $\eps_{\soundness}$ and completeness error $\eps_{\completeness}$. Then  $\prot_{\R'}^\lift$ is a PIOP over $\R$ for the relation $\phi(\REL_{\gparams,\R', \cQ})$ with soundness and completeness errors $\eps_{\soundness}^\lift, \eps_{\completeness}^\lift$ satisfying
        
            $$\eps_{\soundness}^\lift(\gparams, \idx,\inp) = \eps_{\soundness}(\gparams, \phi(\idx), \phi(\inp)), \quad \eps_{\completeness}^\lift(\gparams, \idx,\inp) = \eps_{\completeness}(\gparams, \phi(\idx), \phi(\inp))$$
        
        for all well-formed index-instance pairs $(\idx,\inp)$ for $\phi(\REL_{\gparams,\R, \cQ})$ (note that by \cref{r: well_formedness_preservation}, $(\phi(\idx),\phi(\inp))$ is well-formed as well).
        %
%        Further, $\prot_{\R'}^\lift$ has the same efficiency measures as $\prot_{\R'}$ except for the total complexity, which must take into account $m$ evaluations of $\phi$, for $m$ as in the definition of $\REL_{\R,\cQ}$ and the verifier time which is increased by $q$ evaluations of $\phi$, where $q$ is the number of oracle queries of $\prot_{\R'}$. \albert{Re efficiency measures: Not exactly? Statement to be revised} \luca{How does it sound now?}. 
        \end{lemma}

        
    
       


\subsection{Example: SHA256 hashing + RSA signature verification}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Zip+: A polynomial commitment scheme for $(\QQ[X])[\vec Y]$}
\input{sections/zip+}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Proximity gaps for infinite rings}
\label{sec:proximity-gap}

% \parhead{Informal proximity gap for proposed split encoding}
% Consider a projectable linear code $C$ over $\integers$ with a systematic generator matrix $G = [I_{\dim} \ G']$, and a good random choice of $q$. The honest prover will encode a message $m \in \integers^{\dim}$ as $m \| (G'm \bmod q) \in \integers^{\dim} \times \integers_{q}^{\blocklength-\dim}$.

% Now consider an arbitrary set of vectors over $v_1,\dotsc,v_{m} \in \integers^{\dim} \times \integers_{q}^{\blocklength-\dim}$, and let $(u_1,\dotsc,u_m) \equiv (v_1,\dotsc,v_{m}) \bmod q$. We know from~\cite[Theorem 4.1]{BKS18} that if there exists $u^\ast \in \set{\sum_{i=1}^{m} \alpha_i u_i \mid \alpha_1,\dotsc,\alpha_m \in \integers_q}$ such that $\reldist{u^\ast}{C} > \delta$, then for any $\epsilon > 0$ such that $\delta-\epsilon < \lambda/3$ it holds that
% \[
% \Pr_{\alpha \gets \integers_{q}^m} \left[\reldist{\sum_{i=1}^{m} \alpha_i u_i}{C} < \delta - \epsilon\right] < \frac{1}{\epsilon q}
% \]
% Since for any $\alpha$ we have $\reldist{\sum_{i=1}^{m} \alpha_i v_i}{C} \leq \reldist{\sum_{i=1}^{m} \alpha_i u_i}{C}$, this above result also holds for with respect to the $v_i$.

% We first recall the unique decoding version of the correlated agreement result for linear codes from~\cite{BKS18}.
% \begin{lemma}[Correlated agreement over affine spaces~\cite{BKS18}]
% \label{lemma:correlated-agreement}

% Let $V \subseteq \field^\blocklength$ be a linear space over a finite field $\field$ with $\Delta(C) = \lambda$. Suppose $u^\ast \in \ring^b$ satisfies $\Delta(u^\ast,C) > \delta$, and fix arbitrary $u \in \ring^b$. Let $\challengeset \subseteq \ring$ be an exceptional set. For $\epsilon > 0$ satisfying $\delta - \epsilon < \lambda/3$. Let
% \[
% A = \{\alpha \in \mathcal{C} \mid \distance{u^\ast + \alpha u}{C} < \delta - \varepsilon\}
% \]
% If $|A| > 1/\varepsilon$ then there exist $v, v^\ast \in C$ such that
% \[
% \bigl|\set{i \in [n] \mid (u_i = v_i) \ \wedge \ (u^\ast_i = v^\ast_i)}\bigr| \geq (1 - \delta)\cdot n
% \]
% \end{lemma}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand*{\bibfont}{\small}
\printbibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%